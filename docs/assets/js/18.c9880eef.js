(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{182:function(e,a,t){"use strict";t.r(a);var i=t(0),o=Object(i.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("div",{staticClass:"content"},[t("h4",{attrs:{id:"linearlayout和relativelayout性能对比-百度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linearlayout和relativelayout性能对比-百度","aria-hidden":"true"}},[e._v("#")]),e._v(" LinearLayout和RelativeLayout性能对比-百度")]),e._v(" "),t("ol",[t("li",[e._v("RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure")]),e._v(" "),t("li",[e._v("RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。")]),e._v(" "),t("li",[e._v("在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。")])]),e._v(" "),t("p",[e._v("最后再思考一下文章开头那个矛盾的问题，为什么Google给开发者默认新建了个RelativeLayout，而自己却在DecorView中用了个LinearLayout。因为DecorView的层级深度是已知而且固定的，上面一个标题栏，下面一个内容栏。采用RelativeLayout并不会降低层级深度，所以此时在根节点上用LinearLayout是效率最高的。而之所以给开发者默认新建了个RelativeLayout是希望开发者能采用尽量少的View层级来表达布局以实现性能最优，因为复杂的View嵌套对性能的影响会更大一些。")])])}],!1,null,null,null);o.options.__file="LinearLayout对比RelativeLayout-百度.md";a.default=o.exports}}]);